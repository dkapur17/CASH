# Operating Systems and Networks Assignment 2
## `CASH`: Cliché Average SHell

### Build and Run:
The file already contains the precompiled files and you can launch the shell just by running `./cash`.
If however, you wish to recompile the shell, run the following commands
```bash
make clean
make
./cash
```
`make clean` removes all the object files and the compiled executable.

The `make` command will compile all the `.c` files inside `./src` into `.o` files. It then makes the `obj` directory if it doesn't exist and moves all the `.o` files into that directory. Finally, it links all the object files and the `./cash` executable is generated.

### Directory Structure
On first opening this directory, there will be only 5 items:

* `src` directory that has all the `.c` and `.h` files that have all the source code for the shell.
* `obj` directory that has all the `.o` files corresponding to the `.c` files.
* `Makefile` contains the linking and compiling instructions to make the shell executable.
* `README.md` contains the all implementation details and assumptions for this shell (Hint: You're reading it right now). 
* `cash` is the compiled shell executable

### File Discriptions
Here is a breif discription of each of the files inside the `src` directory:

1. `cash.c` → Contains the main function for the shell. Is essentially just the infinite loop that keeps the shell running. Also has some global variables that need to be used across different `.c` files.

2. `defitions.h` → Contains all the library header files, custom `#define` macros used across all the `.c` files as well as the definiton of a custom `struct`.

3. `functions.c` → Contains all the functions required to implement the behvaiour of the specified commands.

4. `functions.h` → Header file for `functions.c`.

5. `utilites.c` → Contains all the shell and command related utility functions.

6. `utilities.h` → Header file for `utilities.h`.

### General Implementation Details
When the shell is run, for each input, the general stack trace looks something like this:

1. `main()` has the loop where the prompt sting is generated by `generatePS()` in `utilities.c` and commands are inputted from the user.
2. The input is split into `;` seperated command by passing the input string to `parseInputString()` in `utilities.c`.
3. Each `;` seperated command is then sent to `cleanCommand()` in `utilites.c` to get rid of extra whitespaces in the command.
4. Each cleaned command is then sent to `execCommand()` in `utilites.c` which inturn recognizes the keyword in the given command, and then calls the function corresponding to that keyword from `functions.c`.
5. Certain command functions are dependent on other functions. Depending on the nature of these functions, they may either belong to `functions.c` or `utilities.c`.

That is in general how an interation of the infinite loop runs.

### Specification Implementation Details

#### Specification 1: Prompt String

The prompt string is generated by the `generatePS()` method in `utilities.c`. The Prompt string consists of 3 parts.
1. The name of the user. An instance of `struct passwd` is populated with the current user's details using `getpwuid(getuid())`. The current user's name is in `passwd->pw_name`.
2. The hostname of the system. Copied into a buffer using the `gethostname()` method.
3. The current working directory of the shell. Copied into a buffer using the `getcwd()` method. If it is the first time `generatePS()` has been called, it means that our current working directory is also the shell invocation location. This value is saved in a global variable, and is defined as `~` for the running instance of the shell.

*Important: If any of the above functions fail, the prompt string cannot be generated, and the shell **exits abnormally** due to potentially insufficient run-time permissions.*

#### Specification 2: Builtin Commands

The following built in commands were required to be handled:
1. `echo`: Since by the time `echo()` is called from `functions.c`, the string has been stripped of extra white spaces, the function just prints the command, skipping the first 5 characters ('e', 'c', 'h', 'o', ' ').
2. `pwd`: Gets the present working directory of the shell using `getcwd()`.
3. `cd`: Skipping the first 3 characters of the input, ('c', 'd', ' '), leaves us with the path to `cd` to. If the path is absolute, or relative to the current working directory, a single `chdir()` suffices. However, if the path is relative to `~`, we fist `chdir()` to `~` using the absolute path to `~` which is stored as a global variable, then we skip the first two characters of the provided path ('~', '/') and `chdir()` again to the rest of the path.

#### Specification 3: `ls` Command

Implemented in `ls()` in `functions.c`. Here is how it works:

1. Assign a pointer to each argument in the command.
2. Iterate over the pointers and identify the flags. Set `lFlag` and `aFlag` as required.
3. For every argument that is a directory:
    * Create an array of 7 integers, that store the maximum number of characters in a column (there are 7 colums).
    * Open a link to the directory using `opendir()` and save this link in an instance of `DIR*`.
    * Make an instance of `dirent` and use it to iterate over each child of the given directory, using `readdir()`.
    * For each child of the directory, if `lflag` is set, populate and instance of `struct stat` with the child's information using `lstat`. Get the max between the current max column size and the current file's column size for each column. Also accumulate its `st_blocks` value to print `total` later.
    * Now, close and reopen the link to the required directory to reset the pointer location, print the `total` value and again iterate over each child of the directory, printing the required details (just the name is `lFlag` is not set, and all details is `lFlag` is set). If `lFlag` is set, the `ls_printFileDetails()` is called from `functions.c` (which inturn calls `ls_printPermissions()` from `functions.c` to convert the `mode_t` permission bits into the Linux formatted permission string and print it), which handles all the padding (using the array populated from the previous loop over the children) and information printing. The link to the directory is closed again.

#### Specification 4: System commands with and without arguments

If the given command is not recognized as one of those mentioned above, or `pinfo` (next specification) or some others (mentioned later), it is treated as a system command. If the last character of the command string is `&`, the `bExec()` method is called to launch it as a background process, otherwise the `fExec()` method is called to launch it as a foreground process. Both `bExec()` and `fExec()` are defined in `functions.c`.

In both these functions, a pointer is assigned to each space seperated argument. If one of the arguments provided has a path realtive to `~`, it is expanded into its equivalent absolute path.

We then use `fork()` to create a child process and check if it was successful. In the child process, if it is in `bExec()`, we change the child's process group using `setgid(0, 0)`, so that it is sent to the background, and cannot read from the terminal. It can however still write to the terminal if needed.

We then use `execvp()` to load a new executable image onto the child process. If it is successful, the process (foreground/background) starts execution running. If not, an error message is printed regarding the given command and the process is exited from.

On the other hand, in the parent process, if it is in `fExec()`, we wait for the child to exit and then claim the resources using `wait()`. In `bExec()` however, we insert the process into the child pool (explained in specification 6) and return to the prompt.

#### Specification 5: `pinfo`

Implemented in `pinfo()` in `functions.c`. It is first checked if there is a single argument or two arguments. If it is just one, then we need to get information of the current process, whose pid is obtained using the `getpid()` method. Otherwise, the pid is extracted from the command provided. Then contents of `/proc/<pid>/stat` are read into a buffer, and each space seperated value is assigned a pointer.
* The first pointer points to the pid, but this can also be read from the command given.
* The third pointer points to the process status.
* The twenty third pointer points to the memory.

We then read the link whose path is `/proc/<pid>/exe` to get the path to the executable and print it. If however, the mentioned process is a zombie process, this link won't exist, so we print an error message in its place.

#### Specification 6: Finished Background Processes

The way this shell has been implemented, sets a cap on the maximum number of child processes that it can have running simultaneously to 512. A custom structure, `struct pData`, defined in `definitions.h`, stores a process pid and corresponding name. We initilize an array of 512 such stuctures and set all their pids to `-1` using the `initChildren()` method in `utilities.c`, indicating that that particular process is empty. This array is referred to as the **child pool**.

In `main()`, one of the first things we do is install a signal handler using the `installHandler()` method defined in `utilities.c`, that will run each time a `SIGCHLD` signal is sent to the shell. This is done using an instance of `struct sigaction`. *Note that no extra functionality that is provided by `sigaction` but not `signal()` has been used. `sigaction` has been chosen because it is the newer, and arguably better approach to define custom signal handlers.*

When a new background process is created, it is first checked that current number of child processes is less than the maximum limit. If not, the child process is not created and an error is shown. Otherwise, we fill the pid and process name in the first empty location in the array.

When a background process is terminated, the handler is called. Within the handler, we loop over all the children who have exited since the shell recieved the SIGCHLD signal, using `waitpid()`. By default `waitpid()` is blocking, which is not desirable in this situation, so we make use of the `WNOHANG` flag to make it non-blocking. For each pid that we get from `waitpid()`, we look for it in the child pool, and get its name by matching its pid. We print the termination message with the name and pid of the process and "normally" or "abnormally" depending on the exit status of the process. We then replace the pid of that element in the array with `-1` to indicate that that position in the pool is free to be occupied by another child process.

Finally, the prompt string is printed again as an aesthetic feature.

### Bonus Implementation

The only bonus feature that has been implemented is the `nightswatch` feature. Its implemented in the `nightswatch()` method in `functions.c`.

First the arguments are split and it is checked if the command has a valid format. If not, a usage promt is printed and the function returns. Next, the presence of the `-n` flag is checked and the sleep duration is extracted from the string. If the `-n` flag is not given, the sleep duration is assumed to be 2 seconds

If the second keyword in the command is `interrupt`, the `nw_interrupt()` method is called from `functions.c`, otherwise if it is `newborn`, then `nw_newborn()` is called from `functions.c`. If any other keyword is specified, the shell throws an error.

The default configuration of `stdin` makes it blocking and buffered. We use two instances of `struct termios`, one to store the current configuration and the other to store the desired configuration of a given stream (`stdin` in this case). The desired configuration is set to non-buffered. We make `stdin` non-blocking using the `fcntl()` method along with the `O_NONBLOCKING` flag.

For `interrupt`, we then proceed to read `/proc/interrupts`, from which we print the first line once, which is the list of all CPU threads. Then we repreatedly print the third line from that file, corresponding to the interrupts per thread from `i8042` with `IRQ 1` every `n` seconds, while checking `stdin` for the character `q` or `Q` every second, to break from the loop.

For `newborn`, we take the last space seperated value from `/proc/loadavg`, which is the pid of the newest created process. Input is waited on in the same way as mentioned above.

We reload the old configurations for `stdin` and make it buffered again, then flush its contents (if any) and finally set it back to its default blocking behaviour before returning from the function.

### Custom Commands

A few custom commands were added to the shell as well, which weren't mentioned in the requirements:
* `exit` → Simply exits from the shell. Doesn't handle child process termination.
* `clear` → Clears the screen using an ANSI escape sequence. Implemented in `clear()` in `utilities.c`.
* `cproc` → Lists currently running child processes of the shell, with their name and pid. Implemented in `cproc()` in `utilities.c`.

### Assumptions

1. Assumption on `/proc/<pid>/stat` is that the 1st value is the pid of the process, the 3rd value is the process state, and the 23rd value is the memory allocated to the process.
2. Assumption on `/proc/interrupts`, the 1st line has a list of the CPU threads and the 3rd line has the interrupt counts from `i8042` via `IRQ1` per CPU thread.
3. The maximum length of the input string is less than 50000 characters.
4. The number of `;` seperated commands in a single input string are fewer than 100.
5. The number of arguments in each command is fewer than 100.
6. The name of any executable run as a system command has fewer characters than 256.
7. If `-n` flag is not specified for `nightswatch`, the default sleep duration is taken as 2 seconds.